/// <reference types="node" />
import { Pool, PoolConnection, PoolOptions, OkPacket } from 'mysql2';
import { Readable } from 'stream';
export interface DbConfig extends PoolOptions {
    skiptzfix?: boolean;
}
export interface QueryOptions {
    saveAsPrepared?: boolean;
    nestTables?: true | '_';
    rowsAsArray?: boolean;
}
export interface StreamOptions extends QueryOptions {
    highWaterMark?: number;
}
interface canBeStringed {
    toString: () => string;
}
interface BindObject {
    [keys: string]: BindParam;
}
declare type BindParam = boolean | number | string | null | Date | Buffer | canBeStringed | BindObject;
declare type ColTypes = BindParam;
declare type BindInput = BindParam[] | BindObject;
interface StreamIterator<ReturnType> {
    [Symbol.asyncIterator]: () => StreamIterator<ReturnType>;
    next: () => Promise<{
        done?: false;
        value: ReturnType;
    }>;
    return: () => Promise<{
        done: true;
        value: ReturnType;
    }>;
}
interface GenericReadable<T> extends Readable {
    [Symbol.asyncIterator]: () => StreamIterator<T>;
}
export declare class Queryable {
    protected conn: PoolConnection | Pool;
    constructor(conn: PoolConnection | Pool);
    query(sql: string, binds?: BindInput, options?: QueryOptions): Promise<any[] | any[][] | OkPacket | OkPacket[]>;
    getval<ReturnType = ColTypes>(sql: string, binds?: BindInput, options?: QueryOptions): Promise<ReturnType | undefined>;
    getvals<ReturnType = ColTypes>(sql: string, binds?: BindInput, options?: QueryOptions): Promise<ReturnType[]>;
    getrow<ReturnType = any>(sql: string, binds?: BindInput, options?: QueryOptions): Promise<ReturnType | undefined>;
    getall<ReturnType = any>(sql: string, binds?: BindInput, options?: QueryOptions): Promise<ReturnType[]>;
    execute(sql: string, binds?: BindInput, options?: QueryOptions): Promise<boolean>;
    update(sql: string, binds?: BindInput, options?: QueryOptions): Promise<number>;
    delete(sql: string, binds?: BindInput, options?: QueryOptions): Promise<number>;
    insert(sql: string, binds?: BindInput, options?: QueryOptions): Promise<number>;
    protected feedStream<ReturnType>(stream: GenericReadable<ReturnType>, sql: string, binds: BindInput, options?: QueryOptions): void;
    protected handleStreamOptions<ReturnType>(sql: string, bindsOrOptions: any, options?: StreamOptions): {
        binds: any;
        queryOptions: QueryOptions;
        stream: GenericReadable<ReturnType>;
    };
    stream<ReturnType = any>(sql: string, options: StreamOptions): GenericReadable<ReturnType>;
    stream<ReturnType = any>(sql: string, binds?: BindInput, options?: StreamOptions): GenericReadable<ReturnType>;
    iterator<ReturnType = any>(sql: string, options: StreamOptions): StreamIterator<ReturnType>;
    iterator<ReturnType = any>(sql: string, binds?: BindInput, options?: StreamOptions): StreamIterator<ReturnType>;
    in(binds: BindInput, newbinds: BindParam[]): string;
}
export default class Db extends Queryable {
    protected pool: Pool;
    constructor(config?: DbConfig);
    wait(): Promise<void>;
    transaction<ReturnType>(callback: (db: Queryable) => Promise<ReturnType>, options?: {
        retries?: number;
    }): Promise<ReturnType>;
}
export {};
