"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Queryable = void 0;
const mysql2_1 = __importDefault(require("mysql2"));
const stream_1 = require("stream");
class Queryable {
    constructor(conn) {
        this.conn = conn;
    }
    async query(sql, binds, options) {
        if (!options)
            options = {};
        if (typeof binds === 'object' && !Array.isArray(binds))
            options.namedPlaceholders = true;
        try {
            return await new Promise((resolve, reject) => {
                if (options === null || options === void 0 ? void 0 : options.saveAsPrepared) {
                    this.conn.execute({ ...options, sql, values: binds }, (err, result) => {
                        if (err)
                            reject(err);
                        else
                            resolve(result);
                    });
                }
                else {
                    this.conn.query({ ...options, sql, values: binds }, (err, result) => {
                        if (err)
                            reject(err);
                        else
                            resolve(result);
                    });
                }
            });
        }
        catch (e) {
            e.clientstack = e.stack;
            Error.captureStackTrace(e, this.query);
            throw e;
        }
    }
    async getval(sql, binds, options) {
        const row = await this.getrow(sql, binds, { ...options, rowsAsArray: true });
        return row === null || row === void 0 ? void 0 : row[0];
    }
    async getvals(sql, binds, options) {
        const rows = await this.getall(sql, binds, { ...options, rowsAsArray: true });
        return rows.map(r => r[0]);
    }
    async getrow(sql, binds, options) {
        const results = await this.query(sql, binds, options);
        if ((results === null || results === void 0 ? void 0 : results.length) > 0)
            return results === null || results === void 0 ? void 0 : results[0];
    }
    async getall(sql, binds, options) {
        const results = await this.query(sql, binds, options);
        return results;
    }
    async execute(sql, binds, options) {
        await this.query(sql, binds, options);
        return true;
    }
    async update(sql, binds, options) {
        const result = await this.query(sql, binds, options);
        return result.affectedRows;
    }
    async delete(sql, binds, options) {
        return await this.update(sql, binds, options);
    }
    async insert(sql, binds, options) {
        const result = await this.query(sql, binds, options);
        return result.insertId;
    }
    feedStream(stream, sql, binds, options = {}) {
        if (stream.destroyed)
            return;
        const req = (options === null || options === void 0 ? void 0 : options.saveAsPrepared) ? this.conn.execute({ ...options, sql, values: binds }) : this.conn.query({ ...options, sql, values: binds });
        const reqany = req;
        let canceled = false;
        const stacktraceError = {};
        Error.captureStackTrace(stacktraceError, this.feedStream);
        stream._read = () => {
            var _a;
            (_a = reqany._connection) === null || _a === void 0 ? void 0 : _a.resume();
        };
        stream._destroy = (err, cb) => {
            var _a;
            if (err)
                stream.emit('error', err);
            canceled = true;
            (_a = reqany._connection) === null || _a === void 0 ? void 0 : _a.resume();
            cb();
        };
        req.on('result', (row) => {
            if (canceled)
                return;
            if (!stream.push(row)) {
                reqany._connection.pause();
            }
        });
        req.on('error', err => {
            var _a;
            if (canceled)
                return;
            err.clientstack = err.stack;
            err.stack = ((_a = stacktraceError.stack) !== null && _a !== void 0 ? _a : '').replace(/^Error:/, `Error: ${err.message}`);
            stream.emit('error', err);
        });
        req.on('end', () => {
            if (canceled)
                return;
            stream.push(null);
        });
    }
    handleStreamOptions(sql, bindsOrOptions, options) {
        let binds;
        if (!options && ((bindsOrOptions === null || bindsOrOptions === void 0 ? void 0 : bindsOrOptions.highWaterMark) || (bindsOrOptions === null || bindsOrOptions === void 0 ? void 0 : bindsOrOptions.objectMode))) {
            options = bindsOrOptions;
            binds = [];
        }
        else {
            binds = bindsOrOptions;
        }
        const queryOptions = {
            saveAsPrepared: options === null || options === void 0 ? void 0 : options.saveAsPrepared,
            nestTables: options === null || options === void 0 ? void 0 : options.nestTables,
            rowsAsArray: options === null || options === void 0 ? void 0 : options.rowsAsArray
        };
        const streamOptions = {
            highWaterMark: options === null || options === void 0 ? void 0 : options.highWaterMark
        };
        const stream = new stream_1.Readable({ ...streamOptions, objectMode: true });
        stream._read = () => { };
        stream._destroy = (err, cb) => {
            if (err)
                stream.emit('error', err);
            cb();
        };
        return { binds, queryOptions, stream };
    }
    stream(sql, bindsOrOptions, options) {
        const { binds, queryOptions, stream } = this.handleStreamOptions(sql, bindsOrOptions, options);
        this.feedStream(stream, sql, binds, queryOptions);
        return stream;
    }
    iterator(sql, bindsOrOptions, options) {
        const ret = this.stream(sql, bindsOrOptions, options)[Symbol.asyncIterator]();
        return ret;
    }
    in(binds, newbinds) {
        const inElements = [];
        if (Array.isArray(binds)) {
            for (const bind of newbinds) {
                if (Array.isArray(bind)) { // tuple
                    binds.push(...bind);
                    inElements.push(`(${bind.map(() => '?').join(',')})`);
                }
                else { // normal
                    binds.push(bind);
                    inElements.push('?');
                }
            }
        }
        else {
            let startindex = Object.keys(binds).length;
            for (const bind of newbinds) {
                if (Array.isArray(bind)) { // tuple
                    inElements.push(`(${bind.map((str, i) => `:bindin${i + startindex}`).join(',')})`);
                    for (let i = 0; i < bind.length; i++) {
                        binds[`bindin${i + startindex}`] = bind[i];
                    }
                    startindex += bind.length;
                }
                else { // normal
                    inElements.push(`:bindin${startindex}`);
                    binds[`bindin${startindex}`] = bind;
                    startindex++;
                }
            }
        }
        return inElements.join(',');
    }
}
exports.Queryable = Queryable;
class Db extends Queryable {
    constructor(config) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;
        const skiptzfix = ((_a = config === null || config === void 0 ? void 0 : config.skiptzfix) !== null && _a !== void 0 ? _a : false) || Boolean(process.env.MYSQL_SKIPTZFIX);
        config === null || config === void 0 ? true : delete config.skiptzfix;
        const poolSizeString = (_b = process.env.MYSQL_POOL_SIZE) !== null && _b !== void 0 ? _b : process.env.DB_POOL_SIZE;
        const pool = mysql2_1.default.createPool({
            ...config,
            host: (_e = (_d = (_c = config === null || config === void 0 ? void 0 : config.host) !== null && _c !== void 0 ? _c : process.env.MYSQL_HOST) !== null && _d !== void 0 ? _d : process.env.DB_HOST) !== null && _e !== void 0 ? _e : 'mysql',
            port: (_f = config === null || config === void 0 ? void 0 : config.port) !== null && _f !== void 0 ? _f : parseInt((_h = (_g = process.env.MYSQL_PORT) !== null && _g !== void 0 ? _g : process.env.DB_PORT) !== null && _h !== void 0 ? _h : '3306'),
            user: (_l = (_k = (_j = config === null || config === void 0 ? void 0 : config.user) !== null && _j !== void 0 ? _j : process.env.MYSQL_USER) !== null && _k !== void 0 ? _k : process.env.DB_USER) !== null && _l !== void 0 ? _l : 'root',
            password: (_p = (_o = (_m = config === null || config === void 0 ? void 0 : config.password) !== null && _m !== void 0 ? _m : process.env.MYSQL_PASS) !== null && _o !== void 0 ? _o : process.env.DB_PASS) !== null && _p !== void 0 ? _p : 'secret',
            database: (_s = (_r = (_q = config === null || config === void 0 ? void 0 : config.database) !== null && _q !== void 0 ? _q : process.env.MYSQL_DATABASE) !== null && _r !== void 0 ? _r : process.env.DB_DATABASE) !== null && _s !== void 0 ? _s : 'default_database',
            // client side connectTimeout is unstable in mysql2 library
            // it throws an error you can't catch and crashes node
            // best to leave this at 0 (disabled)
            connectTimeout: 0,
            // to harden connections against failure https://github.com/sidorares/node-mysql2/issues/683
            // keepAliveInitialDelay: 10000,
            // enableKeepAlive: true,
            ...(!skiptzfix ? { timezone: 'Z' } : {}),
            ...(poolSizeString ? { connectionLimit: parseInt(poolSizeString) } : {}),
            flags: [...((_t = config === null || config === void 0 ? void 0 : config.flags) !== null && _t !== void 0 ? _t : []), ...(((_u = config === null || config === void 0 ? void 0 : config.flags) === null || _u === void 0 ? void 0 : _u.some(f => f.includes('FOUND_ROWS'))) ? [] : ['-FOUND_ROWS'])]
        });
        if (!skiptzfix) {
            pool.on('connection', function (connection) {
                connection.query('SET time_zone="UTC"');
            });
        }
        super(pool);
        this.pool = pool;
    }
    async wait() {
        while (true) {
            try {
                await this.getrow('select 1');
                break;
            }
            catch (e) {
                if (e.code === 'ENOTFOUND' || e.code === 'ECONNREFUSED') {
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
                else {
                    throw e;
                }
            }
        }
    }
    async transaction(callback, options) {
        const conn = await new Promise((resolve, reject) => {
            this.pool.getConnection((err, conn) => {
                if (err)
                    reject(err);
                else
                    resolve(conn);
            });
        });
        const db = new Queryable(conn);
        try {
            await db.execute('START TRANSACTION');
            try {
                const ret = await callback(db);
                await db.execute('COMMIT');
                return ret;
            }
            catch (e) {
                const isDeadlock = e.errno === 1213;
                if (isDeadlock && (options === null || options === void 0 ? void 0 : options.retries)) {
                    return await this.transaction(callback, { ...options, retries: options.retries - 1 });
                }
                else {
                    if (!isDeadlock)
                        await db.execute('ROLLBACK');
                    throw e;
                }
            }
        }
        finally {
            conn.release();
        }
    }
}
exports.default = Db;
